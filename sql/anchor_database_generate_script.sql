
-- KNOTS --------------------------------------------------------------------------------------------------------------
--
-- Knots are used to store finite sets of values, normally used to describe states
-- of entities (through knotted attributes) or relationships (through knotted ties).
-- Knots have their own surrogate identities and are therefore immutable.
-- Values can be added to the set over time though.
-- Knots should have values that are mutually exclusive and exhaustive.
-- Knots are unfolded when using equivalence.
--
-- Knot table ---------------------------------------------------------------------------------------------------------
-- SHS_ShowingState table
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SHS_ShowingState (
    SHS_ID integer not null,
    SHS_ShowingState varchar(15) not null,
    constraint pkSHS_ShowingState primary key (
        SHS_ID 
    ),
    constraint uqSHS_ShowingState unique (
        SHS_ShowingState
    )
);
-- Knot table ---------------------------------------------------------------------------------------------------------
-- TYP_GenreType table
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.TYP_GenreType (
    TYP_ID integer not null,
    TYP_GenreType varchar(25) not null,
    constraint pkTYP_GenreType primary key (
        TYP_ID 
    ),
    constraint uqTYP_GenreType unique (
        TYP_GenreType
    )
);
-- Knot table ---------------------------------------------------------------------------------------------------------
-- RTT_RatingType table
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.RTT_RatingType (
    RTT_ID smallint not null,
    RTT_RatingType varchar(25) not null,
    constraint pkRTT_RatingType primary key (
        RTT_ID 
    ),
    constraint uqRTT_RatingType unique (
        RTT_RatingType
    )
);
-- ANCHORS AND ATTRIBUTES ---------------------------------------------------------------------------------------------
--
-- Anchors are used to store the identities of entities.
-- Anchors are immutable.
-- Attributes are used to store values for properties of entities.
-- Attributes are mutable, their values may change over one or more types of time.
-- Attributes have four flavors: static, historized, knotted static, and knotted historized.
-- Anchors may have zero or more adjoined attributes.
--
-- Anchor table -------------------------------------------------------------------------------------------------------
-- CI_Cinema table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CI_Cinema (
    CI_ID integer generated by default as identity not null,
    CI_Dummy boolean null,
    constraint pkCI_Cinema primary key (
        CI_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CI_NAM_Cinema_Name table (on CI_Cinema)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CI_NAM_Cinema_Name (
    CI_ID integer not null,
    CI_NAM_Cinema_Name varchar(50) not null,
    constraint fkCI_NAM_Cinema_Name foreign key (
        CI_ID
    ) references public.CI_Cinema (CI_ID),
    constraint pkCI_NAM_Cinema_Name primary key (
        CI_ID 
    ) include (
        CI_NAM_Cinema_Name
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CI_ADR_Cinema_Address table (on CI_Cinema)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CI_ADR_Cinema_Address (
    CI_ID integer not null,
    CI_ADR_Cinema_Address varchar(500) not null,
    constraint fkCI_ADR_Cinema_Address foreign key (
        CI_ID
    ) references public.CI_Cinema (CI_ID),
    constraint pkCI_ADR_Cinema_Address primary key (
        CI_ID 
    ) include (
        CI_ADR_Cinema_Address
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- MV_Movie table (with 4 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.MV_Movie (
    MV_ID integer generated by default as identity not null,
    MV_Dummy boolean null,
    constraint pkMV_Movie primary key (
        MV_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- MV_NAM_Movie_Name table (on MV_Movie)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.MV_NAM_Movie_Name (
    MV_ID integer not null,
    MV_NAM_Movie_Name varchar(50) not null,
    constraint fkMV_NAM_Movie_Name foreign key (
        MV_ID
    ) references public.MV_Movie (MV_ID),
    constraint pkMV_NAM_Movie_Name primary key (
        MV_ID 
    ) include (
        MV_NAM_Movie_Name
    )
);
-- Knotted static attribute table -------------------------------------------------------------------------------------
-- MV_GER_Movie_Gerne table (on MV_Movie)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.MV_GER_Movie_Gerne (
    MV_ID integer not null,
    TYP_ID integer not null,
    constraint fk_A_MV_GER_Movie_Gerne foreign key (
        MV_ID
    ) references public.MV_Movie (MV_ID),
    constraint fk_K_MV_GER_Movie_Gerne foreign key (
        TYP_ID
    ) references public.TYP_GenreType (TYP_ID),
    constraint pkMV_GER_Movie_Gerne primary key (
        MV_ID 
    ) include (
        TYP_ID
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- MV_ATH_Movie_Author table (on MV_Movie)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.MV_ATH_Movie_Author (
    MV_ID integer not null,
    MV_ATH_Movie_Author varchar(50) not null,
    constraint fkMV_ATH_Movie_Author foreign key (
        MV_ID
    ) references public.MV_Movie (MV_ID),
    constraint pkMV_ATH_Movie_Author primary key (
        MV_ID 
    ) include (
        MV_ATH_Movie_Author
    )
);
-- Knotted historized attribute table ---------------------------------------------------------------------------------
-- MV_RAT_Movie_Rating table (on MV_Movie)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.MV_RAT_Movie_Rating (
    MV_ID integer not null,
    RTT_ID smallint not null,
    MV_RAT_ChangedAt timestamp not null,
    constraint fk_A_MV_RAT_Movie_Rating foreign key (
        MV_ID
    ) references public.MV_Movie (MV_ID),
    constraint fk_K_MV_RAT_Movie_Rating foreign key (
        RTT_ID
    ) references public.RTT_RatingType (RTT_ID),
    constraint pkMV_RAT_Movie_Rating primary key (
        MV_ID ,
        MV_RAT_ChangedAt 
    ) include (
        RTT_ID
    )
)
--PARTITION BY RANGE (MV_RAT_ChangedAt)
;
  --CREATE TABLE public.MV_RAT_Movie_Rating_2020 PARTITION OF public.MV_RAT_Movie_Rating
  --FOR VALUES FROM ('2020-01-01 00:00:00') TO ('2021-01-01 00:00:00');	
-- Index for historized field MV_RAT_ChangedAt on table public.MV_RAT_Movie_Rating --------------
-----------------------------------------------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS MV_RAT_Movie_Rating_MV_RAT_ChangedAt_idx ON public.MV_RAT_Movie_Rating (MV_RAT_ChangedAt);	
--CLUSTER public.MV_RAT_Movie_Rating USING MV_RAT_Movie_Rating_MV_RAT_ChangedAt_idx;
-- Anchor table -------------------------------------------------------------------------------------------------------
-- RM_Room table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.RM_Room (
    RM_ID integer generated by default as identity not null,
    RM_Dummy boolean null,
    constraint pkRM_Room primary key (
        RM_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- RM_NOS_Room_NumOfSeats table (on RM_Room)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.RM_NOS_Room_NumOfSeats (
    RM_ID integer not null,
    RM_NOS_Room_NumOfSeats smallint not null,
    constraint fkRM_NOS_Room_NumOfSeats foreign key (
        RM_ID
    ) references public.RM_Room (RM_ID),
    constraint pkRM_NOS_Room_NumOfSeats primary key (
        RM_ID 
    ) include (
        RM_NOS_Room_NumOfSeats
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- RM_NAM_Room_Name table (on RM_Room)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.RM_NAM_Room_Name (
    RM_ID integer not null,
    RM_NAM_Room_Name varchar(50) not null,
    RM_NAM_ChangedAt timestamp not null,
    constraint fkRM_NAM_Room_Name foreign key (
        RM_ID
    ) references public.RM_Room (RM_ID),
    constraint pkRM_NAM_Room_Name primary key (
        RM_ID ,
        RM_NAM_ChangedAt
    ) include (
        RM_NAM_Room_Name
    )
)
--PARTITION BY RANGE (RM_NAM_ChangedAt)
;
  --CREATE TABLE public.RM_NAM_Room_Name_2020 PARTITION OF public.RM_NAM_Room_Name
  --FOR VALUES FROM ('2020-01-01 00:00:00') TO ('2021-01-01 00:00:00');	
-- Index for historized field RM_NAM_ChangedAt on table public.RM_NAM_Room_Name --------------
-----------------------------------------------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS RM_NAM_Room_Name_RM_NAM_ChangedAt_idx ON public.RM_NAM_Room_Name (RM_NAM_ChangedAt);	
--CLUSTER public.RM_NAM_Room_Name USING RM_NAM_Room_Name_RM_NAM_ChangedAt_idx;
-- Anchor table -------------------------------------------------------------------------------------------------------
-- SE_Session table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SE_Session (
    SE_ID integer generated by default as identity not null,
    SE_Dummy boolean null,
    constraint pkSE_Session primary key (
        SE_ID 
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- SE_PRI_Session_Price table (on SE_Session)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SE_PRI_Session_Price (
    SE_ID integer not null,
    SE_PRI_Session_Price decimal(19,4) not null,
    SE_PRI_ChangedAt timestamp not null,
    constraint fkSE_PRI_Session_Price foreign key (
        SE_ID
    ) references public.SE_Session (SE_ID),
    constraint pkSE_PRI_Session_Price primary key (
        SE_ID ,
        SE_PRI_ChangedAt
    ) include (
        SE_PRI_Session_Price
    )
)
--PARTITION BY RANGE (SE_PRI_ChangedAt)
;
  --CREATE TABLE public.SE_PRI_Session_Price_2020 PARTITION OF public.SE_PRI_Session_Price
  --FOR VALUES FROM ('2020-01-01 00:00:00') TO ('2021-01-01 00:00:00');	
-- Index for historized field SE_PRI_ChangedAt on table public.SE_PRI_Session_Price --------------
-----------------------------------------------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS SE_PRI_Session_Price_SE_PRI_ChangedAt_idx ON public.SE_PRI_Session_Price (SE_PRI_ChangedAt);	
--CLUSTER public.SE_PRI_Session_Price USING SE_PRI_Session_Price_SE_PRI_ChangedAt_idx;
-- Static attribute table ---------------------------------------------------------------------------------------------
-- SE_TIM_Session_Time table (on SE_Session)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SE_TIM_Session_Time (
    SE_ID integer not null,
    SE_TIM_Session_Time timestamp not null,
    constraint fkSE_TIM_Session_Time foreign key (
        SE_ID
    ) references public.SE_Session (SE_ID),
    constraint pkSE_TIM_Session_Time primary key (
        SE_ID 
    ) include (
        SE_TIM_Session_Time
    )
);
-- TIES ---------------------------------------------------------------------------------------------------------------
--
-- Ties are used to represent relationships between entities.
-- They come in four flavors: static, historized, knotted static, and knotted historized.
-- Ties have cardinality, constraining how members may participate in the relationship.
-- Every entity that is a member in a tie has a specified role in the relationship.
-- Ties must have at least two anchor roles and zero or more knot roles.
--
-- Knotted historized tie table ---------------------------------------------------------------------------------------
-- CI_at_MV_isShowed_SHS_until table (having 3 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CI_at_MV_isShowed_SHS_until (
    CI_ID_at integer not null, 
    MV_ID_isShowed integer not null, 
    SHS_ID_until integer not null,
    CI_at_MV_isShowed_SHS_until_ChangedAt timestamp not null,
    constraint CI_at_MV_isShowed_SHS_until_fkCI_at foreign key (
        CI_ID_at
    ) references public.CI_Cinema(CI_ID), 
    constraint CI_at_MV_isShowed_SHS_until_fkMV_isShowed foreign key (
        MV_ID_isShowed
    ) references public.MV_Movie(MV_ID), 
    constraint CI_at_MV_isShowed_SHS_until_fkSHS_until foreign key (
        SHS_ID_until
    ) references public.SHS_ShowingState(SHS_ID),
    constraint pkCI_at_MV_isShowed_SHS_until primary key (
        CI_ID_at ,
        MV_ID_isShowed ,
        CI_at_MV_isShowed_SHS_until_ChangedAt 
    )
);
-- Index for historized field CI_at_MV_isShowed_SHS_until_ChangedAt on table public.CI_at_MV_isShowed_SHS_until --------------------------------
-----------------------------------------------------------------------------------------------------------------------
CREATE INDEX IF NOT EXISTS CI_at_MV_isShowed_SHS_until_CI_at_MV_isShowed_SHS_until_ChangedAt_idx ON public.CI_at_MV_isShowed_SHS_until (CI_at_MV_isShowed_SHS_until_ChangedAt);	
--CLUSTER public.CI_at_MV_isShowed_SHS_until USING CI_at_MV_isShowed_SHS_until_CI_at_MV_isShowed_SHS_until_ChangedAt_idx;
-- Static tie table ---------------------------------------------------------------------------------------------------
-- CI_has_RM_the table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CI_has_RM_the (
    CI_ID_has integer not null, 
    RM_ID_the integer not null, 
    constraint CI_has_RM_the_fkCI_has foreign key (
        CI_ID_has
    ) references public.CI_Cinema(CI_ID), 
    constraint CI_has_RM_the_fkRM_the foreign key (
        RM_ID_the
    ) references public.RM_Room(RM_ID), 
    constraint pkCI_has_RM_the primary key (
        RM_ID_the 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- RM_in_SE_takesPlace table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.RM_in_SE_takesPlace (
    RM_ID_in integer not null, 
    SE_ID_takesPlace integer not null, 
    constraint RM_in_SE_takesPlace_fkRM_in foreign key (
        RM_ID_in
    ) references public.RM_Room(RM_ID), 
    constraint RM_in_SE_takesPlace_fkSE_takesPlace foreign key (
        SE_ID_takesPlace
    ) references public.SE_Session(SE_ID), 
    constraint pkRM_in_SE_takesPlace primary key (
        SE_ID_takesPlace 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- SE_at_MV_isShowed table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SE_at_MV_isShowed (
    SE_ID_at integer not null, 
    MV_ID_isShowed integer not null, 
    constraint SE_at_MV_isShowed_fkSE_at foreign key (
        SE_ID_at
    ) references public.SE_Session(SE_ID), 
    constraint SE_at_MV_isShowed_fkMV_isShowed foreign key (
        MV_ID_isShowed
    ) references public.MV_Movie(MV_ID), 
    constraint pkSE_at_MV_isShowed primary key (
        SE_ID_at 
    )
);
-- KNOT EQUIVALENCE VIEWS ---------------------------------------------------------------------------------------------
--
-- Equivalence views combine the identity and equivalent parts of a knot into a single view, making
-- it look and behave like a regular knot. They also make it possible to retrieve data for only the
-- given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- ATTRIBUTE EQUIVALENCE VIEWS ----------------------------------------------------------------------------------------
--
-- Equivalence views of attributes make it possible to retrieve data for only the given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- KEY GENERATORS -----------------------------------------------------------------------------------------------------
--
-- These stored procedures can be used to generate identities of entities.
-- Corresponding anchors must have an incrementing identity column.
--
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kCI_Cinema identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kCI_Cinema(
    requestedNumberOfIdentities bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.CI_Cinema (
                CI_Dummy
            )
            SELECT
                null
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kMV_Movie identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kMV_Movie(
    requestedNumberOfIdentities bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.MV_Movie (
                MV_Dummy
            )
            SELECT
                null
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kRM_Room identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kRM_Room(
    requestedNumberOfIdentities bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.RM_Room (
                RM_Dummy
            )
            SELECT
                null
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kSE_Session identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kSE_Session(
    requestedNumberOfIdentities bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.SE_Session (
                SE_Dummy
            )
            SELECT
                null
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- ATTRIBUTE TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each attribute. There are three types of perspectives: latest,
-- point-in-time and now. 
--
-- The latest perspective shows the latest available information for each attribute.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lMV_RAT_Movie_Rating viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lMV_RAT_Movie_Rating AS
SELECT DISTINCT ON (MV_ID) MV_ID
     , RTT_ID
     , MV_RAT_ChangedAt
  FROM public.MV_RAT_Movie_Rating
 ORDER 
    BY MV_ID DESC
     , MV_RAT_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pMV_RAT_Movie_Rating viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pMV_RAT_Movie_Rating
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( MV_ID integer
      , RTT_ID smallint
      , MV_RAT_ChangedAt timestamp 
      ) 
AS 
'
 SELECT DISTINCT ON (MV_ID) MV_ID
      , RTT_ID
      , MV_RAT_ChangedAt
   FROM public.MV_RAT_Movie_Rating
  WHERE MV_RAT_ChangedAt <= changingTimepoint
  ORDER 
     BY MV_ID DESC
      , MV_RAT_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nMV_RAT_Movie_Rating viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nMV_RAT_Movie_Rating AS
SELECT *
  FROM public.pMV_RAT_Movie_Rating(current_timestamp::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lRM_NAM_Room_Name viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lRM_NAM_Room_Name AS
SELECT DISTINCT ON (RM_ID) RM_ID
     , RM_NAM_Room_Name
     , RM_NAM_ChangedAt
  FROM public.RM_NAM_Room_Name
 ORDER 
    BY RM_ID DESC
     , RM_NAM_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pRM_NAM_Room_Name viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pRM_NAM_Room_Name
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( RM_ID integer
      , RM_NAM_Room_Name varchar(50)
      , RM_NAM_ChangedAt timestamp 
      ) 
AS 
'
 SELECT DISTINCT ON (RM_ID) RM_ID
      , RM_NAM_Room_Name
      , RM_NAM_ChangedAt
   FROM public.RM_NAM_Room_Name
  WHERE RM_NAM_ChangedAt <= changingTimepoint
  ORDER 
     BY RM_ID DESC
      , RM_NAM_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nRM_NAM_Room_Name viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nRM_NAM_Room_Name AS
SELECT *
  FROM public.pRM_NAM_Room_Name(current_timestamp::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lSE_PRI_Session_Price viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lSE_PRI_Session_Price AS
SELECT DISTINCT ON (SE_ID) SE_ID
     , SE_PRI_Session_Price
     , SE_PRI_ChangedAt
  FROM public.SE_PRI_Session_Price
 ORDER 
    BY SE_ID DESC
     , SE_PRI_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pSE_PRI_Session_Price viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pSE_PRI_Session_Price
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( SE_ID integer
      , SE_PRI_Session_Price decimal(19,4)
      , SE_PRI_ChangedAt timestamp 
      ) 
AS 
'
 SELECT DISTINCT ON (SE_ID) SE_ID
      , SE_PRI_Session_Price
      , SE_PRI_ChangedAt
   FROM public.SE_PRI_Session_Price
  WHERE SE_PRI_ChangedAt <= changingTimepoint
  ORDER 
     BY SE_ID DESC
      , SE_PRI_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nSE_PRI_Session_Price viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nSE_PRI_Session_Price AS
SELECT *
  FROM public.pSE_PRI_Session_Price(current_timestamp::timestamp)
;
-- ANCHOR TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each anchor. There are four types of perspectives: latest,
-- point-in-time, difference, and now. They also denormalize the anchor, its attributes,
-- and referenced knots from sixth to third normal form.
--
-- The latest perspective shows the latest available information for each anchor.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- The difference perspective shows changes between the two given timepoints, and for
-- changes in all or a selection of attributes.
--
-- @intervalStart the start of the interval for finding changes
-- @intervalEnd the end of the interval for finding changes
-- @selection a list of mnemonics for tracked attributes, ie 'MNE MON ICS', or null for all
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lCI_Cinema viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lCI_Cinema AS
SELECT CI.CI_ID
     , NAM.CI_NAM_Cinema_Name
     , ADR.CI_ADR_Cinema_Address
  FROM public.CI_Cinema CI
  LEFT 
  JOIN public.CI_NAM_Cinema_Name NAM
    ON NAM.CI_ID = CI.CI_ID
  LEFT 
  JOIN public.CI_ADR_Cinema_Address ADR
    ON ADR.CI_ID = CI.CI_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pCI_Cinema viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pCI_Cinema 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( CI_ID integer
      , CI_NAM_Cinema_Name varchar(50)
      , CI_ADR_Cinema_Address varchar(500)
      ) 
AS 
'
 SELECT CI.CI_ID
      , NAM.CI_NAM_Cinema_Name
      , ADR.CI_ADR_Cinema_Address
   FROM public.CI_Cinema CI
   LEFT 
   JOIN public.CI_NAM_Cinema_Name NAM
     ON NAM.CI_ID = CI.CI_ID
   LEFT 
   JOIN public.CI_ADR_Cinema_Address ADR
     ON ADR.CI_ID = CI.CI_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nCI_Cinema viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nCI_Cinema
AS
SELECT *
  FROM public.pCI_Cinema(current_timestamp::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lMV_Movie viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lMV_Movie AS
SELECT MV.MV_ID
     , NAM.MV_NAM_Movie_Name
     , kGER.TYP_GenreType AS TYP_GenreType
     , GER.TYP_ID
     , ATH.MV_ATH_Movie_Author
     , RAT.MV_RAT_ChangedAt
     , kRAT.RTT_RatingType AS RTT_RatingType
     , RAT.RTT_ID
  FROM public.MV_Movie MV
  LEFT 
  JOIN public.MV_NAM_Movie_Name NAM
    ON NAM.MV_ID = MV.MV_ID
  LEFT 
  JOIN public.MV_GER_Movie_Gerne GER
    ON GER.MV_ID = MV.MV_ID
  LEFT 
  JOIN public.TYP_GenreType kGER
    ON kGER.TYP_ID = GER.TYP_ID
  LEFT 
  JOIN public.MV_ATH_Movie_Author ATH
    ON ATH.MV_ID = MV.MV_ID
  LEFT 
  JOIN public.lMV_RAT_Movie_Rating RAT
    ON RAT.MV_ID = MV.MV_ID
  LEFT 
  JOIN public.RTT_RatingType kRAT
    ON kRAT.RTT_ID = RAT.RTT_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pMV_Movie viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pMV_Movie 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( MV_ID integer
      , MV_NAM_Movie_Name varchar(50)
      , TYP_GenreType varchar(25)
      , TYP_ID integer 
      , MV_ATH_Movie_Author varchar(50)
      , MV_RAT_ChangedAt timestamp
      , RTT_RatingType varchar(25)
      , RTT_ID smallint 
      ) 
AS 
'
 SELECT MV.MV_ID
      , NAM.MV_NAM_Movie_Name
      , kGER.TYP_GenreType AS TYP_GenreType
      , GER.TYP_ID
      , ATH.MV_ATH_Movie_Author
      , RAT.MV_RAT_ChangedAt
      , kRAT.RTT_RatingType AS RTT_RatingType
      , RAT.RTT_ID
   FROM public.MV_Movie MV
   LEFT 
   JOIN public.MV_NAM_Movie_Name NAM
     ON NAM.MV_ID = MV.MV_ID
   LEFT 
   JOIN public.MV_GER_Movie_Gerne GER
     ON GER.MV_ID = MV.MV_ID
   LEFT 
   JOIN public.TYP_GenreType kGER
     ON kGER.TYP_ID = GER.TYP_ID
   LEFT 
   JOIN public.MV_ATH_Movie_Author ATH
     ON ATH.MV_ID = MV.MV_ID
   LEFT 
   JOIN public.pMV_RAT_Movie_Rating(changingTimepoint) RAT
     ON RAT.MV_ID = MV.MV_ID
   LEFT 
   JOIN public.RTT_RatingType kRAT
     ON kRAT.RTT_ID = RAT.RTT_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nMV_Movie viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nMV_Movie
AS
SELECT *
  FROM public.pMV_Movie(current_timestamp::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dMV_Movie showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.dMV_Movie 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , MV_ID integer
      , MV_NAM_Movie_Name varchar(50)
      , TYP_GenreType varchar(25)
      , TYP_ID integer 
      , MV_ATH_Movie_Author varchar(50)
      , MV_RAT_ChangedAt timestamp
      , RTT_RatingType varchar(25)
      , RTT_ID smallint 
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pMV.*
   FROM (
          SELECT DISTINCT MV_ID AS MV_ID
               , MV_RAT_ChangedAt::timestamp inspectedTimepoint
               , ''RAT'' AS mnemonic
            FROM public.MV_RAT_Movie_Rating
           WHERE (selection is null OR selection like ''%RAT%'')
             AND MV_RAT_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL public.pMV_Movie(timepoints.inspectedTimepoint) pMV
  WHERE pMV.MV_ID = timepoints.MV_ID;
' 
LANGUAGE SQL STABLE
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lRM_Room viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lRM_Room AS
SELECT RM.RM_ID
     , NOS.RM_NOS_Room_NumOfSeats
     , cast(null as boolean) as Deletable_RM_NAM
     , NAM.RM_NAM_ChangedAt
     , NAM.RM_NAM_Room_Name
  FROM public.RM_Room RM
  LEFT 
  JOIN public.RM_NOS_Room_NumOfSeats NOS
    ON NOS.RM_ID = RM.RM_ID
  LEFT 
  JOIN public.lRM_NAM_Room_Name NAM
    ON NAM.RM_ID = RM.RM_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pRM_Room viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pRM_Room 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( RM_ID integer
      , RM_NOS_Room_NumOfSeats smallint
      , RM_NAM_ChangedAt timestamp
      , RM_NAM_Room_Name varchar(50)
      ) 
AS 
'
 SELECT RM.RM_ID
      , NOS.RM_NOS_Room_NumOfSeats
      , NAM.RM_NAM_ChangedAt
      , NAM.RM_NAM_Room_Name
   FROM public.RM_Room RM
   LEFT 
   JOIN public.RM_NOS_Room_NumOfSeats NOS
     ON NOS.RM_ID = RM.RM_ID
   LEFT 
   JOIN public.pRM_NAM_Room_Name(changingTimepoint) NAM
     ON NAM.RM_ID = RM.RM_ID
;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nRM_Room viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nRM_Room
AS
SELECT *
  FROM public.pRM_Room(current_timestamp::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dRM_Room showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.dRM_Room 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , RM_ID integer
      , RM_NOS_Room_NumOfSeats smallint
      , RM_NAM_ChangedAt timestamp
      , RM_NAM_Room_Name varchar(50)
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pRM.*
   FROM (
          SELECT DISTINCT RM_ID AS RM_ID
               , RM_NAM_ChangedAt::timestamp inspectedTimepoint
               , ''NAM'' AS mnemonic
            FROM public.RM_NAM_Room_Name
           WHERE (selection is null OR selection like ''%NAM%'')
             AND RM_NAM_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL public.pRM_Room(timepoints.inspectedTimepoint) pRM
  WHERE pRM.RM_ID = timepoints.RM_ID;
' 
LANGUAGE SQL STABLE
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lSE_Session viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.lSE_Session AS
SELECT SE.SE_ID
     , PRI.SE_PRI_ChangedAt
     , PRI.SE_PRI_Session_Price
     , TIM.SE_TIM_Session_Time
  FROM public.SE_Session SE
  LEFT 
  JOIN public.lSE_PRI_Session_Price PRI
    ON PRI.SE_ID = SE.SE_ID
  LEFT 
  JOIN public.SE_TIM_Session_Time TIM
    ON TIM.SE_ID = SE.SE_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pSE_Session viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.pSE_Session 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( SE_ID integer
      , SE_PRI_ChangedAt timestamp
      , SE_PRI_Session_Price decimal(19,4)
      , SE_TIM_Session_Time timestamp
      ) 
AS 
'
 SELECT SE.SE_ID
      , PRI.SE_PRI_ChangedAt
      , PRI.SE_PRI_Session_Price
      , TIM.SE_TIM_Session_Time
   FROM public.SE_Session SE
   LEFT 
   JOIN public.pSE_PRI_Session_Price(changingTimepoint) PRI
     ON PRI.SE_ID = SE.SE_ID
   LEFT 
   JOIN public.SE_TIM_Session_Time TIM
     ON TIM.SE_ID = SE.SE_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nSE_Session viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.nSE_Session
AS
SELECT *
  FROM public.pSE_Session(current_timestamp::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dSE_Session showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION public.dSE_Session 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , SE_ID integer
      , SE_PRI_ChangedAt timestamp
      , SE_PRI_Session_Price decimal(19,4)
      , SE_TIM_Session_Time timestamp
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pSE.*
   FROM (
          SELECT DISTINCT SE_ID AS SE_ID
               , SE_PRI_ChangedAt::timestamp inspectedTimepoint
               , ''PRI'' AS mnemonic
            FROM public.SE_PRI_Session_Price
           WHERE (selection is null OR selection like ''%PRI%'')
             AND SE_PRI_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL public.pSE_Session(timepoints.inspectedTimepoint) pSE
  WHERE pSE.SE_ID = timepoints.SE_ID;
' 
LANGUAGE SQL STABLE
;
-- ANCHOR TRIGGERS ---------------------------------------------------------------------------------------------------
--
-- The following triggers on the latest view make it behave like a table.
-- There are three different 'instead of' triggers: insert, update, and delete.
-- They will ensure that such operations are propagated to the underlying tables
-- in a consistent way. Default values are used for some columns if not provided
-- by the corresponding SQL statements.
--
-- For idempotent attributes, only changes that represent a value different from
-- the previous or following value are stored. Others are silently ignored in
-- order to avoid unnecessary temporal duplicates.
--
-- INSTEAD OF INSERT trigger ----------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS iti_lCI_Cinema ON public.lCI_Cinema;
--DROP FUNCTION IF EXISTS public.iti_lCI_Cinema();
CREATE OR REPLACE FUNCTION public.iti_lCI_Cinema() RETURNS trigger AS '
    BEGIN
        -- create temporary table to keep inserted rows in
        CREATE TEMPORARY TABLE IF NOT EXISTS _tmp_it_CI_Cinema (
            CI_ID integer not null,
                    CI_NAM_Cinema_Name varchar(50) null,
                    CI_ADR_Cinema_Address varchar(500) null
                ) ON COMMIT DROP;
        -- generate anchor ID (if not provided)
        IF (NEW.CI_ID IS NULL) THEN 
            INSERT INTO public.CI_Cinema (
                CI_Dummy
            ) VALUES (
                null
            );
            SELECT
                lastval() 
            INTO NEW.CI_ID;
        -- if anchor ID is provided then let''s insert it into the anchor table
        -- but only if that ID is not present in the anchor table
        ELSE
            INSERT INTO public.CI_Cinema (
                CI_ID
            )
            SELECT
                NEW.CI_ID
            WHERE NOT EXISTS(
	            SELECT
	                CI_ID 
	            FROM public.CI_Cinema
	            WHERE CI_ID = NEW.CI_ID
	            LIMIT 1
            );
        END IF;
        -- insert row into temporary table
    	INSERT INTO _tmp_it_CI_Cinema (
            CI_ID,
            CI_NAM_Cinema_Name,
            CI_ADR_Cinema_Address
    	) VALUES (
    	    NEW.CI_ID,
            NEW.CI_NAM_Cinema_Name,
            NEW.CI_ADR_Cinema_Address
    	);
        INSERT INTO public.CI_NAM_Cinema_Name (
            CI_ID,
            CI_NAM_Cinema_Name
        )
        SELECT
            i.CI_ID,
            i.CI_NAM_Cinema_Name
        FROM
            _tmp_it_CI_Cinema i
        WHERE
            i.CI_NAM_Cinema_Name is not null;
        INSERT INTO public.CI_ADR_Cinema_Address (
            CI_ID,
            CI_ADR_Cinema_Address
        )
        SELECT
            i.CI_ID,
            i.CI_ADR_Cinema_Address
        FROM
            _tmp_it_CI_Cinema i
        WHERE
            i.CI_ADR_Cinema_Address is not null;
        DROP TABLE IF EXISTS _tmp_it_CI_Cinema;
        RETURN NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER iti_lCI_Cinema
INSTEAD OF INSERT ON public.lCI_Cinema
FOR EACH ROW
EXECUTE PROCEDURE public.iti_lCI_Cinema();
--INSTEAD OF UPDATE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itu_lCI_Cinema ON public.lCI_Cinema;
--DROP FUNCTION IF EXISTS public.itu_lCI_Cinema();
CREATE OR REPLACE FUNCTION public.itu_lCI_Cinema() RETURNS trigger AS '
  BEGIN
        IF NEW.CI_NAM_Cinema_Name IS NOT NULL AND OLD.CI_NAM_Cinema_Name <> NEW.CI_NAM_Cinema_Name THEN 
            UPDATE public.CI_NAM_Cinema_Name
            SET CI_NAM_Cinema_Name = NEW.CI_NAM_Cinema_Name
            WHERE CI_ID = OLD.CI_ID;
       END IF;
        IF NEW.CI_ADR_Cinema_Address IS NOT NULL AND OLD.CI_ADR_Cinema_Address <> NEW.CI_ADR_Cinema_Address THEN 
            UPDATE public.CI_ADR_Cinema_Address
            SET CI_ADR_Cinema_Address = NEW.CI_ADR_Cinema_Address
            WHERE CI_ID = OLD.CI_ID;
       END IF;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itu_lCI_Cinema
INSTEAD OF UPDATE ON public.lCI_Cinema
FOR EACH ROW
EXECUTE PROCEDURE public.itu_lCI_Cinema();
--INSTEAD OF DELETE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itd_lCI_Cinema ON public.lCI_Cinema;
--DROP FUNCTION IF EXISTS public.itd_lCI_Cinema();
CREATE OR REPLACE FUNCTION public.itd_lCI_Cinema() RETURNS trigger AS '
  BEGIN
    DELETE FROM public.CI_NAM_Cinema_Name NAM
    WHERE 
        OLD.CI_ID = NAM.CI_ID;
    DELETE FROM public.CI_ADR_Cinema_Address ADR
    WHERE 
        OLD.CI_ID = ADR.CI_ID;
    DELETE FROM public.CI_Cinema CI
    WHERE
        OLD.CI_ID = CI.CI_ID;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itd_lCI_Cinema
INSTEAD OF DELETE ON public.lCI_Cinema
FOR EACH ROW
EXECUTE PROCEDURE public.itd_lCI_Cinema();
-- INSTEAD OF INSERT trigger ----------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS iti_lMV_Movie ON public.lMV_Movie;
--DROP FUNCTION IF EXISTS public.iti_lMV_Movie();
CREATE OR REPLACE FUNCTION public.iti_lMV_Movie() RETURNS trigger AS '
    BEGIN
        -- create temporary table to keep inserted rows in
        CREATE TEMPORARY TABLE IF NOT EXISTS _tmp_it_MV_Movie (
            MV_ID integer not null,
                    MV_NAM_Movie_Name varchar(50) null,
                    TYP_GenreType varchar(25) null,
                    TYP_ID integer null,
                    MV_ATH_Movie_Author varchar(50) null,
                    MV_RAT_ChangedAt timestamp null,
                    RTT_RatingType varchar(25) null,
                    RTT_ID smallint null
                ) ON COMMIT DROP;
        -- generate anchor ID (if not provided)
        IF (NEW.MV_ID IS NULL) THEN 
            INSERT INTO public.MV_Movie (
                MV_Dummy
            ) VALUES (
                null
            );
            SELECT
                lastval() 
            INTO NEW.MV_ID;
        -- if anchor ID is provided then let''s insert it into the anchor table
        -- but only if that ID is not present in the anchor table
        ELSE
            INSERT INTO public.MV_Movie (
                MV_ID
            )
            SELECT
                NEW.MV_ID
            WHERE NOT EXISTS(
	            SELECT
	                MV_ID 
	            FROM public.MV_Movie
	            WHERE MV_ID = NEW.MV_ID
	            LIMIT 1
            );
        END IF;
        -- insert row into temporary table
    	INSERT INTO _tmp_it_MV_Movie (
            MV_ID,
            MV_NAM_Movie_Name,
            TYP_GenreType,
            TYP_ID,
            MV_ATH_Movie_Author,
            MV_RAT_ChangedAt,
            RTT_RatingType,
            RTT_ID
    	) VALUES (
    	    NEW.MV_ID,
            NEW.MV_NAM_Movie_Name,
            NEW.TYP_GenreType,
            NEW.TYP_ID,
            NEW.MV_ATH_Movie_Author,
            COALESCE(NEW.MV_RAT_ChangedAt, CAST(current_timestamp AS timestamp)),
            NEW.RTT_RatingType,
            NEW.RTT_ID
    	);
        INSERT INTO public.MV_NAM_Movie_Name (
            MV_ID,
            MV_NAM_Movie_Name
        )
        SELECT
            i.MV_ID,
            i.MV_NAM_Movie_Name
        FROM
            _tmp_it_MV_Movie i
        WHERE
            i.MV_NAM_Movie_Name is not null;
        INSERT INTO public.MV_GER_Movie_Gerne (
            MV_ID,
            TYP_ID
        )
        SELECT
            i.MV_ID,
            COALESCE(i.TYP_ID, kTYP.TYP_ID) 
        FROM
            _tmp_it_MV_Movie i
        LEFT JOIN
            public.TYP_GenreType kTYP
        ON
            kTYP.TYP_GenreType = i.TYP_GenreType
        WHERE
            COALESCE(i.TYP_ID, kTYP.TYP_ID) is not null;
        INSERT INTO public.MV_ATH_Movie_Author (
            MV_ID,
            MV_ATH_Movie_Author
        )
        SELECT
            i.MV_ID,
            i.MV_ATH_Movie_Author
        FROM
            _tmp_it_MV_Movie i
        WHERE
            i.MV_ATH_Movie_Author is not null;
        INSERT INTO public.MV_RAT_Movie_Rating (
            MV_ID,
            MV_RAT_ChangedAt,
            RTT_ID
        )
        SELECT
            i.MV_ID,
            i.MV_RAT_ChangedAt,
            COALESCE(i.RTT_ID, kRTT.RTT_ID) 
        FROM
            _tmp_it_MV_Movie i
        LEFT JOIN
            public.RTT_RatingType kRTT
        ON
            kRTT.RTT_RatingType = i.RTT_RatingType
        WHERE
            COALESCE(i.RTT_ID, kRTT.RTT_ID) is not null;
        DROP TABLE IF EXISTS _tmp_it_MV_Movie;
        RETURN NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER iti_lMV_Movie
INSTEAD OF INSERT ON public.lMV_Movie
FOR EACH ROW
EXECUTE PROCEDURE public.iti_lMV_Movie();
--INSTEAD OF UPDATE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itu_lMV_Movie ON public.lMV_Movie;
--DROP FUNCTION IF EXISTS public.itu_lMV_Movie();
CREATE OR REPLACE FUNCTION public.itu_lMV_Movie() RETURNS trigger AS '
  BEGIN
        IF NEW.MV_NAM_Movie_Name IS NOT NULL AND OLD.MV_NAM_Movie_Name <> NEW.MV_NAM_Movie_Name THEN 
            UPDATE public.MV_NAM_Movie_Name
            SET MV_NAM_Movie_Name = NEW.MV_NAM_Movie_Name
            WHERE MV_ID = OLD.MV_ID;
       END IF;
        IF NEW.TYP_ID IS NOT NULL AND OLD.TYP_ID <> NEW.TYP_ID THEN 
            UPDATE public.MV_GER_Movie_Gerne
            SET TYP_ID = NEW.TYP_ID
            WHERE MV_ID = OLD.MV_ID;
       END IF;
        IF NEW.MV_ATH_Movie_Author IS NOT NULL AND OLD.MV_ATH_Movie_Author <> NEW.MV_ATH_Movie_Author THEN 
            UPDATE public.MV_ATH_Movie_Author
            SET MV_ATH_Movie_Author = NEW.MV_ATH_Movie_Author
            WHERE MV_ID = OLD.MV_ID;
       END IF;
        IF NEW.RTT_ID IS NOT NULL AND OLD.RTT_ID <> NEW.RTT_ID THEN 
            INSERT INTO public.MV_RAT_Movie_Rating(
                MV_ID,
                RTT_ID,
                MV_RAT_ChangedAt
            )VALUES(
                OLD.MV_ID,
                NEW.RTT_ID,
                CASE 
                    WHEN OLD.MV_RAT_ChangedAt <> NEW.MV_RAT_ChangedAt THEN
                        NEW.MV_RAT_ChangedAt
                    ELSE
                        CAST(current_timestamp AS timestamp)
                END
            ); 
       END IF;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itu_lMV_Movie
INSTEAD OF UPDATE ON public.lMV_Movie
FOR EACH ROW
EXECUTE PROCEDURE public.itu_lMV_Movie();
--INSTEAD OF DELETE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itd_lMV_Movie ON public.lMV_Movie;
--DROP FUNCTION IF EXISTS public.itd_lMV_Movie();
CREATE OR REPLACE FUNCTION public.itd_lMV_Movie() RETURNS trigger AS '
  BEGIN
    DELETE FROM public.MV_NAM_Movie_Name NAM
    WHERE 
        OLD.MV_ID = NAM.MV_ID;
    DELETE FROM public.MV_GER_Movie_Gerne GER
    WHERE 
        OLD.MV_ID = GER.MV_ID;
    DELETE FROM public.MV_ATH_Movie_Author ATH
    WHERE 
        OLD.MV_ID = ATH.MV_ID;
    DELETE FROM public.MV_RAT_Movie_Rating RAT
    WHERE 
        OLD.MV_RAT_ChangedAt = RAT.MV_RAT_ChangedAt
    AND
        OLD.MV_ID = RAT.MV_ID;
    DELETE FROM public.MV_Movie MV
    WHERE
        OLD.MV_ID = MV.MV_ID;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itd_lMV_Movie
INSTEAD OF DELETE ON public.lMV_Movie
FOR EACH ROW
EXECUTE PROCEDURE public.itd_lMV_Movie();
-- INSTEAD OF INSERT trigger ----------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS iti_lRM_Room ON public.lRM_Room;
--DROP FUNCTION IF EXISTS public.iti_lRM_Room();
CREATE OR REPLACE FUNCTION public.iti_lRM_Room() RETURNS trigger AS '
    BEGIN
        -- create temporary table to keep inserted rows in
        CREATE TEMPORARY TABLE IF NOT EXISTS _tmp_it_RM_Room (
            RM_ID integer not null,
                    RM_NOS_Room_NumOfSeats smallint null,
                    RM_NAM_ChangedAt timestamp null,
                    RM_NAM_Room_Name varchar(50) null
                ) ON COMMIT DROP;
        -- generate anchor ID (if not provided)
        IF (NEW.RM_ID IS NULL) THEN 
            INSERT INTO public.RM_Room (
                RM_Dummy
            ) VALUES (
                null
            );
            SELECT
                lastval() 
            INTO NEW.RM_ID;
        -- if anchor ID is provided then let''s insert it into the anchor table
        -- but only if that ID is not present in the anchor table
        ELSE
            INSERT INTO public.RM_Room (
                RM_ID
            )
            SELECT
                NEW.RM_ID
            WHERE NOT EXISTS(
	            SELECT
	                RM_ID 
	            FROM public.RM_Room
	            WHERE RM_ID = NEW.RM_ID
	            LIMIT 1
            );
        END IF;
        -- insert row into temporary table
    	INSERT INTO _tmp_it_RM_Room (
            RM_ID,
            RM_NOS_Room_NumOfSeats,
            RM_NAM_ChangedAt,
            RM_NAM_Room_Name
    	) VALUES (
    	    NEW.RM_ID,
            NEW.RM_NOS_Room_NumOfSeats,
            COALESCE(NEW.RM_NAM_ChangedAt, CAST(current_timestamp AS timestamp)),
            NEW.RM_NAM_Room_Name
    	);
        INSERT INTO public.RM_NOS_Room_NumOfSeats (
            RM_ID,
            RM_NOS_Room_NumOfSeats
        )
        SELECT
            i.RM_ID,
            i.RM_NOS_Room_NumOfSeats
        FROM
            _tmp_it_RM_Room i
        WHERE
            i.RM_NOS_Room_NumOfSeats is not null;
        INSERT INTO public.RM_NAM_Room_Name (
            RM_ID,
            RM_NAM_ChangedAt,
            RM_NAM_Room_Name
        )
        SELECT
            i.RM_ID,
            i.RM_NAM_ChangedAt,
            i.RM_NAM_Room_Name
        FROM
            _tmp_it_RM_Room i
        WHERE
            i.RM_NAM_Room_Name is not null;
        DROP TABLE IF EXISTS _tmp_it_RM_Room;
        RETURN NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER iti_lRM_Room
INSTEAD OF INSERT ON public.lRM_Room
FOR EACH ROW
EXECUTE PROCEDURE public.iti_lRM_Room();
--INSTEAD OF UPDATE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itu_lRM_Room ON public.lRM_Room;
--DROP FUNCTION IF EXISTS public.itu_lRM_Room();
CREATE OR REPLACE FUNCTION public.itu_lRM_Room() RETURNS trigger AS '
  BEGIN
        IF NEW.RM_NOS_Room_NumOfSeats IS NOT NULL AND OLD.RM_NOS_Room_NumOfSeats <> NEW.RM_NOS_Room_NumOfSeats THEN 
            UPDATE public.RM_NOS_Room_NumOfSeats
            SET RM_NOS_Room_NumOfSeats = NEW.RM_NOS_Room_NumOfSeats
            WHERE RM_ID = OLD.RM_ID;
       END IF;
        IF NEW.RM_NAM_Room_Name IS NULL AND NEW.Deletable_RM_NAM = true THEN
            CREATE TABLE IF NOT EXISTS public.RM_NAM_Room_Name_Deleted AS SELECT *, null::timestamp as RM_NAM_Deleted FROM public.RM_NAM_Room_Name WHERE FALSE;
            WITH tmp AS 
            (DELETE FROM public.RM_NAM_Room_Name WHERE RM_ID = OLD.RM_ID RETURNING *) 
	        INSERT INTO public.RM_NAM_Room_Name_Deleted SELECT *, localtimestamp(0) FROM tmp where RM_ID = OLD.RM_ID;
        END IF;
        IF NEW.RM_NAM_Room_Name IS NOT NULL AND OLD.RM_NAM_Room_Name <> NEW.RM_NAM_Room_Name THEN 
            INSERT INTO public.RM_NAM_Room_Name(
                RM_ID,
                RM_NAM_Room_Name,
                RM_NAM_ChangedAt
            )VALUES(
                OLD.RM_ID,
                NEW.RM_NAM_Room_Name,
                CASE 
                    WHEN OLD.RM_NAM_ChangedAt <> NEW.RM_NAM_ChangedAt THEN
                        NEW.RM_NAM_ChangedAt
                    ELSE
                        CAST(current_timestamp AS timestamp)
                END
            ); 
       END IF;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itu_lRM_Room
INSTEAD OF UPDATE ON public.lRM_Room
FOR EACH ROW
EXECUTE PROCEDURE public.itu_lRM_Room();
--INSTEAD OF DELETE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itd_lRM_Room ON public.lRM_Room;
--DROP FUNCTION IF EXISTS public.itd_lRM_Room();
CREATE OR REPLACE FUNCTION public.itd_lRM_Room() RETURNS trigger AS '
  BEGIN
    DELETE FROM public.RM_NOS_Room_NumOfSeats NOS
    WHERE 
        OLD.RM_ID = NOS.RM_ID;
    DELETE FROM public.RM_NAM_Room_Name NAM
    WHERE 
        OLD.RM_NAM_ChangedAt = NAM.RM_NAM_ChangedAt
    AND
        OLD.RM_ID = NAM.RM_ID;
    DELETE FROM public.RM_Room RM
    WHERE
        OLD.RM_ID = RM.RM_ID;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itd_lRM_Room
INSTEAD OF DELETE ON public.lRM_Room
FOR EACH ROW
EXECUTE PROCEDURE public.itd_lRM_Room();
-- INSTEAD OF INSERT trigger ----------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS iti_lSE_Session ON public.lSE_Session;
--DROP FUNCTION IF EXISTS public.iti_lSE_Session();
CREATE OR REPLACE FUNCTION public.iti_lSE_Session() RETURNS trigger AS '
    BEGIN
        -- create temporary table to keep inserted rows in
        CREATE TEMPORARY TABLE IF NOT EXISTS _tmp_it_SE_Session (
            SE_ID integer not null,
                    SE_PRI_ChangedAt timestamp null,
                    SE_PRI_Session_Price decimal(19,4) null,
                    SE_TIM_Session_Time timestamp null
                ) ON COMMIT DROP;
        -- generate anchor ID (if not provided)
        IF (NEW.SE_ID IS NULL) THEN 
            INSERT INTO public.SE_Session (
                SE_Dummy
            ) VALUES (
                null
            );
            SELECT
                lastval() 
            INTO NEW.SE_ID;
        -- if anchor ID is provided then let''s insert it into the anchor table
        -- but only if that ID is not present in the anchor table
        ELSE
            INSERT INTO public.SE_Session (
                SE_ID
            )
            SELECT
                NEW.SE_ID
            WHERE NOT EXISTS(
	            SELECT
	                SE_ID 
	            FROM public.SE_Session
	            WHERE SE_ID = NEW.SE_ID
	            LIMIT 1
            );
        END IF;
        -- insert row into temporary table
    	INSERT INTO _tmp_it_SE_Session (
            SE_ID,
            SE_PRI_ChangedAt,
            SE_PRI_Session_Price,
            SE_TIM_Session_Time
    	) VALUES (
    	    NEW.SE_ID,
            COALESCE(NEW.SE_PRI_ChangedAt, CAST(current_timestamp AS timestamp)),
            NEW.SE_PRI_Session_Price,
            NEW.SE_TIM_Session_Time
    	);
        INSERT INTO public.SE_PRI_Session_Price (
            SE_ID,
            SE_PRI_ChangedAt,
            SE_PRI_Session_Price
        )
        SELECT
            i.SE_ID,
            i.SE_PRI_ChangedAt,
            i.SE_PRI_Session_Price
        FROM
            _tmp_it_SE_Session i
        WHERE
            i.SE_PRI_Session_Price is not null;
        INSERT INTO public.SE_TIM_Session_Time (
            SE_ID,
            SE_TIM_Session_Time
        )
        SELECT
            i.SE_ID,
            i.SE_TIM_Session_Time
        FROM
            _tmp_it_SE_Session i
        WHERE
            i.SE_TIM_Session_Time is not null;
        DROP TABLE IF EXISTS _tmp_it_SE_Session;
        RETURN NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER iti_lSE_Session
INSTEAD OF INSERT ON public.lSE_Session
FOR EACH ROW
EXECUTE PROCEDURE public.iti_lSE_Session();
--INSTEAD OF UPDATE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itu_lSE_Session ON public.lSE_Session;
--DROP FUNCTION IF EXISTS public.itu_lSE_Session();
CREATE OR REPLACE FUNCTION public.itu_lSE_Session() RETURNS trigger AS '
  BEGIN
        IF NEW.SE_PRI_Session_Price IS NOT NULL AND OLD.SE_PRI_Session_Price <> NEW.SE_PRI_Session_Price THEN 
            INSERT INTO public.SE_PRI_Session_Price(
                SE_ID,
                SE_PRI_Session_Price,
                SE_PRI_ChangedAt
            )VALUES(
                OLD.SE_ID,
                NEW.SE_PRI_Session_Price,
                CASE 
                    WHEN OLD.SE_PRI_ChangedAt <> NEW.SE_PRI_ChangedAt THEN
                        NEW.SE_PRI_ChangedAt
                    ELSE
                        CAST(current_timestamp AS timestamp)
                END
            ); 
       END IF;
        IF NEW.SE_TIM_Session_Time IS NOT NULL AND OLD.SE_TIM_Session_Time <> NEW.SE_TIM_Session_Time THEN 
            UPDATE public.SE_TIM_Session_Time
            SET SE_TIM_Session_Time = NEW.SE_TIM_Session_Time
            WHERE SE_ID = OLD.SE_ID;
       END IF;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itu_lSE_Session
INSTEAD OF UPDATE ON public.lSE_Session
FOR EACH ROW
EXECUTE PROCEDURE public.itu_lSE_Session();
--INSTEAD OF DELETE trigger ---------------------------------------------------------------------------------------------------------
--DROP TRIGGER IF EXISTS itd_lSE_Session ON public.lSE_Session;
--DROP FUNCTION IF EXISTS public.itd_lSE_Session();
CREATE OR REPLACE FUNCTION public.itd_lSE_Session() RETURNS trigger AS '
  BEGIN
    DELETE FROM public.SE_PRI_Session_Price PRI
    WHERE 
        OLD.SE_PRI_ChangedAt = PRI.SE_PRI_ChangedAt
    AND
        OLD.SE_ID = PRI.SE_ID;
    DELETE FROM public.SE_TIM_Session_Time TIM
    WHERE 
        OLD.SE_ID = TIM.SE_ID;
    DELETE FROM public.SE_Session SE
    WHERE
        OLD.SE_ID = SE.SE_ID;
    RETURN NEW;
  END;
' LANGUAGE plpgsql;
CREATE TRIGGER itd_lSE_Session
INSTEAD OF DELETE ON public.lSE_Session
FOR EACH ROW
EXECUTE PROCEDURE public.itd_lSE_Session();
-- SCHEMA EVOLUTION ---------------------------------------------------------------------------------------------------
--
-- The following tables, views, and functions are used to track schema changes
-- over time, as well as providing every XML that has been 'executed' against
-- the database.
--
-- Schema table -------------------------------------------------------------------------------------------------------
-- The schema table holds every xml that has been executed against the database
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public._Schema 
     ( version int generated by default as identity primary key
     , activation timestamp not null
     , schema jsonb not null
     )
;
-- Insert the JSON schema (as of now)
INSERT INTO public._Schema 
     ( activation
     , schema
     )
SELECT current_timestamp
     , '{
   "schema": {
      "format": "0.99.10",
      "date": "2024-03-27",
      "time": "20:55:50",
      "metadata": {
         "changingRange": "timestamp",
         "encapsulation": "public",
         "identity": "integer",
         "metadataPrefix": "Metadata",
         "metadataType": "bigint",
         "metadataUsage": "false",
         "changingSuffix": "ChangedAt",
         "identitySuffix": "ID",
         "positIdentity": "bigint",
         "positGenerator": "true",
         "positingRange": "timestamp",
         "positingSuffix": "PositedAt",
         "positorRange": "smallint",
         "positorSuffix": "Positor",
         "reliabilityRange": "decimal(5,2)",
         "reliabilitySuffix": "Reliability",
         "defaultReliability": "1",
         "deleteReliability": "0",
         "assertionSuffix": "Assertion",
         "partitioning": "false",
         "entityIntegrity": "false",
         "restatability": "true",
         "idempotency": "false",
         "assertiveness": "true",
         "naming": "original",
         "positSuffix": "Posit",
         "annexSuffix": "Annex",
         "chronon": "timestamp",
         "now": "current_timestamp",
         "dummySuffix": "Dummy",
         "versionSuffix": "Version",
         "statementTypeSuffix": "StatementType",
         "checksumSuffix": "Checksum",
         "businessViews": "false",
         "decisiveness": "false",
         "equivalence": "false",
         "equivalentSuffix": "EQ",
         "equivalentRange": "smallint",
         "databaseTarget": "PostgreSQL",
         "temporalization": "uni",
         "deletability": "false",
         "deletablePrefix": "Deletable",
         "deletionSuffix": "Deleted",
         "privacy": "Ignore",
         "checksum": "false",
         "triggers": "true",
         "knotAliases": "false"
      },
      "knot": {
         "SHS": {
            "id": "SHS",
            "mnemonic": "SHS",
            "descriptor": "ShowingState",
            "identity": "integer",
            "dataRange": "varchar(15)",
            "metadata": {
               "capsule": "public",
               "generator": "false"
            },
            "layout": {
               "x": "1067.71",
               "y": "393.51",
               "fixed": "false"
            }
         },
         "TYP": {
            "id": "TYP",
            "mnemonic": "TYP",
            "descriptor": "GenreType",
            "identity": "integer",
            "dataRange": "varchar(25)",
            "metadata": {
               "capsule": "public",
               "generator": "false"
            },
            "layout": {
               "x": "716.59",
               "y": "221.38",
               "fixed": "false"
            }
         },
         "RTT": {
            "id": "RTT",
            "mnemonic": "RTT",
            "descriptor": "RatingType",
            "identity": "smallint",
            "dataRange": "varchar(25)",
            "metadata": {
               "capsule": "public",
               "generator": "false"
            },
            "layout": {
               "x": "973.43",
               "y": "546.15",
               "fixed": "false"
            }
         }
      },
      "knots": [
         "SHS",
         "TYP",
         "RTT"
      ],
      "anchor": {
         "CI": {
            "id": "CI",
            "mnemonic": "CI",
            "descriptor": "Cinema",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "attribute": {
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "dataRange": "varchar(50)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "1487.15",
                     "y": "338.54",
                     "fixed": "true"
                  }
               },
               "ADR": {
                  "id": "ADR",
                  "mnemonic": "ADR",
                  "descriptor": "Address",
                  "dataRange": "varchar(500)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "1366.44",
                     "y": "460.35",
                     "fixed": "true"
                  }
               }
            },
            "attributes": [
               "NAM",
               "ADR"
            ],
            "layout": {
               "x": "1350.54",
               "y": "342.56",
               "fixed": "true"
            }
         },
         "MV": {
            "id": "MV",
            "mnemonic": "MV",
            "descriptor": "Movie",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "attribute": {
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "dataRange": "varchar(50)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "775.36",
                     "y": "333.33",
                     "fixed": "true"
                  }
               },
               "GER": {
                  "id": "GER",
                  "mnemonic": "GER",
                  "descriptor": "Gerne",
                  "knotRange": "TYP",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "791.64",
                     "y": "235.22",
                     "fixed": "false"
                  }
               },
               "ATH": {
                  "id": "ATH",
                  "mnemonic": "ATH",
                  "descriptor": "Author",
                  "dataRange": "varchar(50)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "869.61",
                     "y": "372.33",
                     "fixed": "true"
                  }
               },
               "RAT": {
                  "id": "RAT",
                  "mnemonic": "RAT",
                  "descriptor": "Rating",
                  "timeRange": "timestamp",
                  "knotRange": "RTT",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "941.01",
                     "y": "495.66",
                     "fixed": "true"
                  }
               }
            },
            "attributes": [
               "NAM",
               "GER",
               "ATH",
               "RAT"
            ],
            "layout": {
               "x": "881.75",
               "y": "288.39",
               "fixed": "true"
            }
         },
         "RM": {
            "id": "RM",
            "mnemonic": "RM",
            "descriptor": "Room",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "attribute": {
               "NOS": {
                  "id": "NOS",
                  "mnemonic": "NOS",
                  "descriptor": "NumOfSeats",
                  "dataRange": "smallint",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "1522.75",
                     "y": "-44.15",
                     "fixed": "true"
                  }
               },
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(50)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "true"
                  },
                  "layout": {
                     "x": "1533.40",
                     "y": "38.90",
                     "fixed": "true"
                  }
               }
            },
            "attributes": [
               "NOS",
               "NAM"
            ],
            "layout": {
               "x": "1393.49",
               "y": "25.99",
               "fixed": "true"
            }
         },
         "SE": {
            "id": "SE",
            "mnemonic": "SE",
            "descriptor": "Session",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "attribute": {
               "PRI": {
                  "id": "PRI",
                  "mnemonic": "PRI",
                  "descriptor": "Price",
                  "timeRange": "timestamp",
                  "dataRange": "decimal(19,4)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "884.55",
                     "y": "-10.29",
                     "fixed": "false"
                  }
               },
               "TIM": {
                  "id": "TIM",
                  "mnemonic": "TIM",
                  "descriptor": "Time",
                  "dataRange": "timestamp",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "public",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "956.76",
                     "y": "-90.43",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "PRI",
               "TIM"
            ],
            "layout": {
               "x": "954.59",
               "y": "-9.50",
               "fixed": "true"
            }
         }
      },
      "anchors": [
         "CI",
         "MV",
         "RM",
         "SE"
      ],
      "tie": {
         "CI_at_MV_isShowed_SHS_until": {
            "id": "CI_at_MV_isShowed_SHS_until",
            "timeRange": "timestamp",
            "anchorRole": {
               "CI_at": {
                  "id": "CI_at",
                  "role": "at",
                  "type": "CI",
                  "identifier": "true"
               },
               "MV_isShowed": {
                  "id": "MV_isShowed",
                  "role": "isShowed",
                  "type": "MV",
                  "identifier": "true"
               }
            },
            "roles": [
               "CI_at",
               "MV_isShowed",
               "SHS_until"
            ],
            "knotRole": {
               "SHS_until": {
                  "id": "SHS_until",
                  "role": "until",
                  "type": "SHS",
                  "identifier": "false"
               }
            },
            "metadata": {
               "capsule": "public",
               "restatable": "true",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "1089.42",
               "y": "321.24",
               "fixed": "true"
            }
         },
         "CI_has_RM_the": {
            "id": "CI_has_RM_the",
            "anchorRole": {
               "CI_has": {
                  "id": "CI_has",
                  "role": "has",
                  "type": "CI",
                  "identifier": "false"
               },
               "RM_the": {
                  "id": "RM_the",
                  "role": "the",
                  "type": "RM",
                  "identifier": "true"
               }
            },
            "roles": [
               "CI_has",
               "RM_the"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "1365.11",
               "y": "168.24",
               "fixed": "true"
            }
         },
         "RM_in_SE_takesPlace": {
            "id": "RM_in_SE_takesPlace",
            "anchorRole": {
               "RM_in": {
                  "id": "RM_in",
                  "role": "in",
                  "type": "RM",
                  "identifier": "false"
               },
               "SE_takesPlace": {
                  "id": "SE_takesPlace",
                  "role": "takesPlace",
                  "type": "SE",
                  "identifier": "true"
               }
            },
            "roles": [
               "RM_in",
               "SE_takesPlace"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "1168.20",
               "y": "8.28",
               "fixed": "false"
            }
         },
         "SE_at_MV_isShowed": {
            "id": "SE_at_MV_isShowed",
            "anchorRole": {
               "SE_at": {
                  "id": "SE_at",
                  "role": "at",
                  "type": "SE",
                  "identifier": "true"
               },
               "MV_isShowed": {
                  "id": "MV_isShowed",
                  "role": "isShowed",
                  "type": "MV",
                  "identifier": "false"
               }
            },
            "roles": [
               "SE_at",
               "MV_isShowed"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "914.57",
               "y": "132.18",
               "fixed": "true"
            }
         }
      },
      "ties": [
         "CI_at_MV_isShowed_SHS_until",
         "CI_has_RM_the",
         "RM_in_SE_takesPlace",
         "SE_at_MV_isShowed"
      ]
   }
}'
;
-- Schema expanded view -----------------------------------------------------------------------------------------------
-- A view of the schema table that expands the XML attributes into columns
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Schema_Expanded 
AS
SELECT version
     , activation
     , (schema -> 'schema' ->> 'format') as format
     , (schema -> 'schema' ->> 'date')::date as date
     , (schema -> 'schema' ->> 'time')::time as time
     , (schema -> 'schema' -> 'metadata' ->> 'temporalization') as temporalization
     , (schema -> 'schema' -> 'metadata' ->> 'databaseTarget') as databaseTarget	
     , (schema -> 'schema' -> 'metadata' ->> 'changingRange') as changingRange
     , (schema -> 'schema' -> 'metadata' ->> 'encapsulation') as encapsulation
     , (schema -> 'schema' -> 'metadata' ->> 'identity') as identity
     , (schema -> 'schema' -> 'metadata' ->> 'metadataPrefix') as metadataPrefix
     , (schema -> 'schema' -> 'metadata' ->> 'metadataType') as metadataType
     , (schema -> 'schema' -> 'metadata' ->> 'metadataUsage') as metadataUsage	
     , (schema -> 'schema' -> 'metadata' ->> 'changingSuffix') as changingSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'identitySuffix') as identitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'positIdentity') as positIdentity
     , (schema -> 'schema' -> 'metadata' ->> 'positGenerator') as positGenerator	
     , (schema -> 'schema' -> 'metadata' ->> 'positingRange') as positingRange
     , (schema -> 'schema' -> 'metadata' ->> 'positingSuffix') as positingSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'positorRange') as positorRange
     , (schema -> 'schema' -> 'metadata' ->> 'positorSuffix') as positorSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilityRange') as reliabilityRange
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilitySuffix') as reliabilitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliableCutoff') as reliableCutoff
     , (schema -> 'schema' -> 'metadata' ->> 'deleteReliability') as deleteReliability	
     , (schema -> 'schema' -> 'metadata' ->> 'reliableSuffix') as reliableSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'partitioning') as partitioning
     , (schema -> 'schema' -> 'metadata' ->> 'entityIntegrity') as entityIntegrity
     , (schema -> 'schema' -> 'metadata' ->> 'restatability') as restatability
     , (schema -> 'schema' -> 'metadata' ->> 'idempotency') as idempotency
     , (schema -> 'schema' -> 'metadata' ->> 'assertiveness') as assertiveness	
     , (schema -> 'schema' -> 'metadata' ->> 'naming') as naming
     , (schema -> 'schema' -> 'metadata' ->> 'positSuffix') as positSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'annexSuffix') as annexSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'chronon') as chronon
     , (schema -> 'schema' -> 'metadata' ->> 'now') as now
     , (schema -> 'schema' -> 'metadata' ->> 'dummySuffix') as dummySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'statementTypeSuffix') as statementTypeSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'checksumSuffix') as checksumSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'businessViews') as businessViews
     , (schema -> 'schema' -> 'metadata' ->> 'equivalence') as equivalence
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentSuffix') as equivalentSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentRange') as equivalentRange	
  FROM public._Schema
;
-- Anchor view --------------------------------------------------------------------------------------------------------
-- The anchor view shows information about all the anchors in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Anchor
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || v.descriptor as name
     , v.descriptor	
     , a.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(cardinality(v.attributes),0) as numberOfAttributes
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_to_record(a.value) as v(descriptor text, identity text, "dataRange" text, metadata jsonb, attributes text[])
;	
-- Knot view ----------------------------------------------------------------------------------------------------------
-- The knot view shows information about all the knots in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Knot
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , k.key || '_' || v.descriptor as name	
     , v.descriptor
     , k.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as datarange	
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(v.metadata ->> 'checksum','false') as checksum
     , v.description	
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'knot') as k
     , jsonb_to_record(k.value) as v(descriptor text, identity text, "dataRange" text, description text, metadata jsonb)
;
-- Attribute view -----------------------------------------------------------------------------------------------------
-- The attribute view shows information about all the attributes in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Attribute
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || t.key || '_' || (a.value ->> 'descriptor') || '_' || v.descriptor as name
     , v.descriptor 
     , t.key as mnemonic 
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as dataRange
     , case when v."knotRange" is null then false else true end as knotted
     , v."knotRange" as knotRange
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange 
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'privacy' as privacy
     , coalesce(v.metadata ->> 'checksum','false') as checksum 
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
     , a.key as anchorMnemonic
     , (a.value ->> 'descriptor') as anchorDescriptor
     , (a.value ->> 'identity') as anchorIdentity
     , v.metadata ->> 'deletable' as deletable
     , v.metadata ->> 'encryptionGroup' as encryptionGroup
     , v.description
     , coalesce(cardinality(v.keys),0) as numberKeyOfStops
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_each(a.value -> 'attribute') as t
     , jsonb_to_record(t.value) as v(descriptor text, identity text, "dataRange" text, "knotRange" text, "timeRange" text, description text, metadata jsonb, keys text[]) 
;
-- Tie view -----------------------------------------------------------------------------------------------------------
-- The tie view shows information about all the ties in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Tie
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , t.key as name
     , v.metadata ->> 'capsule' as capsule	
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange
     , cardinality(roles) as numberOfRoles
     , array(select value ->> 'role' from jsonb_each(v."anchorRole")) || array(select value ->> 'role' from jsonb_each(v."knotRole")) as roles
     , cardinality(array(select jsonb_object_keys(v."anchorRole"))) as numberOfAnchors
     , array(select split_part(jsonb_object_keys(v."anchorRole"),'_',1)) as anchors
     , coalesce(cardinality(array(select jsonb_object_keys(v."knotRole")))) as numberOfKnots
     , array(select split_part(jsonb_object_keys(v."knotRole"),'_',1)) as knots	
     --, v."anchorRole"
     , cardinality(array(select value ->> 'identifier' from jsonb_each(v."anchorRole") where value ->> 'identifier' = 'true') || array(select value ->> 'identifier' from jsonb_each(v."knotRole") where value ->> 'identifier' = 'true')) as identifiers
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'tie') as t
     , jsonb_to_record(t.value) as v("timeRange" text, roles text[], metadata jsonb, "anchorRole" jsonb, "knotRole" jsonb)
;
-- DESCRIPTIONS -------------------------------------------------------------------------------------------------------